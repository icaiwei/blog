(window.webpackJsonp=window.webpackJsonp||[]).push([[158],{2509:function(v,_,t){v.exports=t.p+"assets/img/image-20230624172236634.1566b3b5.png"},2510:function(v,_,t){v.exports=t.p+"assets/img/image-20230624175043735.ef568bf0.png"},2957:function(v,_,t){"use strict";t.r(_);var a=t(0),e=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"docker镜像原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#docker镜像原理"}},[v._v("#")]),v._v(" Docker镜像原理")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("Docker镜像的本质？")]),v._v(" "),_("p",[v._v("本质是分层的文件系统")]),v._v(" "),_("p",[v._v("Linux文件系统由bootfs和rootfs两部分组成")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("bootfs：包含bootloader和kernel")])]),v._v(" "),_("li",[_("p",[v._v("rootfs：root文件系统，包含/dev，/bin等目录")])]),v._v(" "),_("li",[_("p",[v._v("不同linux发行版，bootfs基本一样，而rootfs不同")])]),v._v(" "),_("li",[_("p",[v._v("Docker镜像是由特殊的文件系统叠加而成")])]),v._v(" "),_("li",[_("p",[v._v("最底端是bootfs，并使用宿主机的bootfs")])]),v._v(" "),_("li",[_("p",[v._v("第二层是rootfs")])]),v._v(" "),_("li",[_("p",[v._v("然后再往上叠加其他镜像文件")])]),v._v(" "),_("li",[_("p",[v._v("统一文件系统技术能够将不同层整合成一个文件系统，为这些层提供了一个统一的视角，这样就隐藏了多层的存在，在用户角度看来，只存在一个文件系统")])]),v._v(" "),_("li",[_("p",[v._v("一个镜像可以放在另一个镜像上面。位于下面的镜像称为父镜像，最底部的镜像称为基础镜像")])]),v._v(" "),_("li",[_("p",[v._v("当从一个镜像启动容器时，Docker会在最顶层加载一个读写文件系统作为容器")]),v._v(" "),_("p",[_("img",{attrs:{src:t(2509),alt:"image-20230624172236634"}})])])])]),v._v(" "),_("li",[_("p",[v._v("Docker中一个centos镜像只有200M，而一个ISO镜像需要几个G？")]),v._v(" "),_("p",[v._v("CentOS的ISO镜像文件包含 bootfs 和 rootfs，而 docker 的 centos 镜像复用操作系统的bootfs，只有 rootfs 和其他镜像层")])]),v._v(" "),_("li",[_("p",[v._v("Docker中Tomcat镜像有500M，一个Tomcat安装包只有70M？")]),v._v(" "),_("p",[v._v("由于docker中镜像是分层的，tomcat 虽然只有70M，但需要依赖父镜像和基础镜像，所以整个对外暴露的 tomcat 镜像有500M")])])]),v._v(" "),_("h2",{attrs:{id:"镜像制作"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#镜像制作"}},[v._v("#")]),v._v(" 镜像制作")]),v._v(" "),_("h3",{attrs:{id:"容器转为镜像"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#容器转为镜像"}},[v._v("#")]),v._v(" 容器转为镜像")]),v._v(" "),_("div",{staticClass:"language-shell line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-shell"}},[_("code",[_("span",{pre:!0,attrs:{class:"token function"}},[v._v("docker")]),v._v(" commit 容器id 镜像名称:版本号\n"),_("span",{pre:!0,attrs:{class:"token function"}},[v._v("docker")]),v._v(" save "),_("span",{pre:!0,attrs:{class:"token parameter variable"}},[v._v("-o")]),v._v(" 压缩文件名称 镜像名称:版本号\n"),_("span",{pre:!0,attrs:{class:"token function"}},[v._v("docker")]),v._v(" load "),_("span",{pre:!0,attrs:{class:"token parameter variable"}},[v._v("-i")]),v._v(" 压缩文件名称\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br"),_("span",{staticClass:"line-number"},[v._v("3")]),_("br")])]),_("h3",{attrs:{id:"dockerfile"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#dockerfile"}},[v._v("#")]),v._v(" dockerfile")]),v._v(" "),_("h4",{attrs:{id:"概念"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#概念"}},[v._v("#")]),v._v(" 概念")]),v._v(" "),_("ul",[_("li",[v._v("dockerfile是一个文本文件")]),v._v(" "),_("li",[v._v("包含了一条条指令")]),v._v(" "),_("li",[v._v("每一条指令构建一层，基于基础镜像，最终构建出一个新的镜像")]),v._v(" "),_("li",[v._v("对于开发人员：可以为开发团队提供一个完全一致的开发环境")]),v._v(" "),_("li",[v._v("对于测试人员：可以直接拿开发时所构建的镜像或者通过dockerfile文件构建一个新的镜像开始工作")]),v._v(" "),_("li",[v._v("对于运维人员：在部署时，可以实现应用的无缝移植")])]),v._v(" "),_("p",[_("img",{attrs:{src:t(2510),alt:"image-20230624175043735"}})]),v._v(" "),_("h4",{attrs:{id:"关键字"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#关键字"}},[v._v("#")]),v._v(" 关键字")]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("关键字")]),v._v(" "),_("th",[v._v("作用")]),v._v(" "),_("th",[v._v("备注")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("FROM")]),v._v(" "),_("td",[v._v("指定父镜像")]),v._v(" "),_("td",[v._v("指定dockerfile基于哪个image创建")])]),v._v(" "),_("tr",[_("td",[v._v("MAINTAINER")]),v._v(" "),_("td",[v._v("作者信息")]),v._v(" "),_("td",[v._v("用于表明这个dockerfile是谁写的")])]),v._v(" "),_("tr",[_("td",[v._v("LABEL")]),v._v(" "),_("td",[v._v("标签")]),v._v(" "),_("td",[v._v("用于标明dockerfile标签，可以使用LABEL代替MAINTAINER，最终都可以在docker image基本信息中查看")])]),v._v(" "),_("tr",[_("td",[v._v("RUN")]),v._v(" "),_("td",[v._v("执行命令")]),v._v(" "),_("td",[v._v('执行一段命令，默认是 /bin/sh，格式：RUN command 或者 RUN ["command","param1","param2"]')])]),v._v(" "),_("tr",[_("td",[v._v("CMD")]),v._v(" "),_("td",[v._v("容器启动命令")]),v._v(" "),_("td",[v._v('提供启动容器时候的默认命令，和ENTRYPOINT配合使用，格式：CMD command param1 param2 或者 CMD ["command","param1","param2"]')])]),v._v(" "),_("tr",[_("td",[v._v("ENTRYPOINT")]),v._v(" "),_("td",[v._v("入口")]),v._v(" "),_("td",[v._v("一般在只做一些执行就关闭的容器中会使用")])]),v._v(" "),_("tr",[_("td",[v._v("COPY")]),v._v(" "),_("td",[v._v("复制文件")]),v._v(" "),_("td",[v._v("build 的时候复制文件到 image 中")])]),v._v(" "),_("tr",[_("td",[v._v("ADD")]),v._v(" "),_("td",[v._v("添加文件")]),v._v(" "),_("td",[v._v("build 的时候添加文件到 image 中，不仅仅局限于当前 build 的上下文，可以来源于远程服务")])]),v._v(" "),_("tr",[_("td",[v._v("ENV")]),v._v(" "),_("td",[v._v("环境变量")]),v._v(" "),_("td",[v._v("指定 build 时候的环境变量，可以在启动容器时，通过 -e 覆盖，格式 ENV name=value")])]),v._v(" "),_("tr",[_("td",[v._v("ARG")]),v._v(" "),_("td",[v._v("构建参数")]),v._v(" "),_("td",[v._v("只在构建的时候使用的参数，如果有ENV，那么 ENV 优先级高于 ARG")])]),v._v(" "),_("tr",[_("td",[v._v("VOLUME")]),v._v(" "),_("td",[v._v("定义外部可以挂载的数据卷")]),v._v(" "),_("td",[v._v('指定 build 的 image 哪些目录可以启动的时候挂载到文件系统中，启动容器的时候使用 -v 绑定，格式VOLUME ["目录"]')])]),v._v(" "),_("tr",[_("td",[v._v("EXPOSE")]),v._v(" "),_("td",[v._v("暴露端口")]),v._v(" "),_("td",[v._v("定义容器运行时候监听的端口，启动容器时使用 -p 来绑定暴露端口，格式：EXPOSE 8080 或者 EXPOSE 8080/UDP")])]),v._v(" "),_("tr",[_("td",[v._v("WORKDIR")]),v._v(" "),_("td",[v._v("工作目录")]),v._v(" "),_("td",[v._v("指定容器内部的工作目录，如果没有创建则自动创建，如果指定 / 使用的是绝对地址，如果不是 / 开头，那么是在上一条 WORKDIR 的路径的相对路径")])]),v._v(" "),_("tr",[_("td",[v._v("USER")]),v._v(" "),_("td",[v._v("指定执行用户")]),v._v(" "),_("td",[v._v("指定 build 或者启动时，用户在 RUN CMD ENTRYPOINT 执行的时候的用户")])]),v._v(" "),_("tr",[_("td",[v._v("HEALTHCHECK")]),v._v(" "),_("td",[v._v("健康检查")]),v._v(" "),_("td",[v._v("指定监测当前容器的健康监测的命令")])]),v._v(" "),_("tr",[_("td",[v._v("ONBUILD")]),v._v(" "),_("td",[v._v("触发器")]),v._v(" "),_("td",[v._v("当存在 ONBUILD 关键字的镜像作为基础镜像时，执行 FROM 完成之后，会执行 ONBUILD ，但是不影响当前镜像")])]),v._v(" "),_("tr",[_("td",[v._v("STOPSIGNAL")]),v._v(" "),_("td",[v._v("发送信号量到宿主机")]),v._v(" "),_("td",[v._v("STOPSIGNAL指令设置将发送到容器的系统调用信号以退出")])]),v._v(" "),_("tr",[_("td",[v._v("SHELL")]),v._v(" "),_("td",[v._v("指定执行脚本的shell")]),v._v(" "),_("td",[v._v("指定RUN CMD ENTRYPOINT 执行命令的时候使用")])])])]),v._v(" "),_("h4",{attrs:{id:"制作springboot镜像"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#制作springboot镜像"}},[v._v("#")]),v._v(" 制作springboot镜像")]),v._v(" "),_("ol",[_("li",[v._v("定义父镜像 "),_("code",[v._v("FROM java:8")])]),v._v(" "),_("li",[v._v("定义作者信息 "),_("code",[v._v("MAINTAINER icaiwei <icaiwei@icaiwei.com")]),v._v(">")]),v._v(" "),_("li",[v._v("将 jar 包添加到容器 "),_("code",[v._v("ADD springboot.jar app.jar")])]),v._v(" "),_("li",[v._v("定义容器启动执行的命令"),_("code",[v._v("CMD java -jar app.jar")])]),v._v(" "),_("li",[v._v("通过dockerfile构建镜像 "),_("code",[v._v("docker build -f dockerfile文件路径 -t 镜像名称:版本")])])]),v._v(" "),_("h4",{attrs:{id:"自定义centos镜像"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#自定义centos镜像"}},[v._v("#")]),v._v(" 自定义centos镜像")]),v._v(" "),_("ol",[_("li",[v._v("定义父镜像 "),_("code",[v._v("FROM centos:7")])]),v._v(" "),_("li",[v._v("定义作者信息 "),_("code",[v._v("MAINTAINER icaiwei <icaiwei@icaiwei.com")]),v._v(">")]),v._v(" "),_("li",[v._v("安装vim "),_("code",[v._v("yum install -y vim")])]),v._v(" "),_("li",[v._v("定义默认工作目录"),_("code",[v._v("WORKDIR /usr")])]),v._v(" "),_("li",[v._v("定义容器启动命令"),_("code",[v._v("CMD /bin/bash")])]),v._v(" "),_("li",[v._v("通过dockerfile构建镜像 "),_("code",[v._v("docker build -f dockerfile文件路径 -t 镜像名称:版本")])])]),v._v(" "),_("h2",{attrs:{id:"服务编排"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#服务编排"}},[v._v("#")]),v._v(" 服务编排")]),v._v(" "),_("p",[v._v("按照一定的业务规则批量管理容器")]),v._v(" "),_("h3",{attrs:{id:"docker-compose"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#docker-compose"}},[v._v("#")]),v._v(" Docker Compose")]),v._v(" "),_("p",[v._v("Docker Compose是一个编排多容器分布式部署的工具，提供命令集管理容器化应用的完整开发周期，包括服务构建，启动和停止。")]),v._v(" "),_("p",[v._v("使用步骤：")]),v._v(" "),_("ol",[_("li",[v._v("利用 Dockerfile 定义运行环境镜像")]),v._v(" "),_("li",[v._v("使用 docker-compose.yml 定义组成应用的各服务")]),v._v(" "),_("li",[v._v("运行 "),_("code",[v._v("docker-compose up")]),v._v(" 启动应用")])]),v._v(" "),_("h3",{attrs:{id:"安装使用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#安装使用"}},[v._v("#")]),v._v(" 安装使用")]),v._v(" "),_("h5",{attrs:{id:"安装"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#安装"}},[v._v("#")]),v._v(" 安装")])])}),[],!1,null,null,null);_.default=e.exports}}]);